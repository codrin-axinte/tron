<?php

namespace App\Telegram;

use App\Enums\PendingActionType;
use App\Models\User;
use App\Telegram\Data\SetHandlerData;
use App\Telegram\Traits\ExtendsSetupChat;
use DefStudio\Telegraph\DTO\InlineQuery;
use DefStudio\Telegraph\Handlers\WebhookHandler;
use DefStudio\Telegraph\Keyboard\Button;
use DefStudio\Telegraph\Keyboard\Keyboard;
use Illuminate\Support\Stringable;
use ReflectionMethod;

/**
 * @method start(?User $user = null)
 */
class DefaultWebhookHandler extends WebhookHandler
{
    use ExtendsSetupChat;

    protected int $messageId = 0;

    protected int $callbackQueryId = 0;

    /**
     * @var array|string[]
     */
    protected array $commands = [];

    public function __construct(array $commands = [])
    {
        parent::__construct();
        $this->commands = $commands;
    }

    /**
     * @throws \Exception
     */
    public function __call(string $name, array $arguments)
    {
        if (!array_key_exists($name, $this->commands)) {
            $this->handleUnknownCommand(new Stringable($name));

            return;
        }

        $command = app($this->commands[$name]);
        $command->setHandler(
            new SetHandlerData(
                bot: $this->bot,
                chat: $this->chat,
                messageId: $this->messageId,
                callbackQueryId: $this->callbackQueryId,
                handler: $this,
                request: $this->request,
                data: $this->data,
                originalKeyboard: $this->originalKeyboard,
                message: $this->message,
                callbackQuery: $this->callbackQuery,
                currentUser: $this->currentUser
            )
        );

        if ($command->authorized()) {
            $command(...$arguments);
        } else {
            $this->chat->message('👮‍ You are not authorized to use this command.')->dispatch();
        }

    }

    protected function handleChatMessage(Stringable $text): void
    {
        $user = $this->currentUser;

        if (!$user) {
            \Log::error('User not found', ['user' => $user, 'message' => $text->value()]);
            return;
        }

        $pendingTransaction = $user
            ->pendingActions()
            ->where('type', PendingActionType::Withdraw)
            ->latest()
            ->first();

        if ($pendingTransaction) {
            $pendingTransaction->meta = array_merge($pendingTransaction->meta, [
                'address' => $text->value(),
            ]);
            $pendingTransaction->save();

            $this->chat
                ->markdown('Is this the correct address? ' . $text)
                ->keyboard(Keyboard::make()->buttons([
                    Button::make('✅ Yes, that is correct')
                        ->action('withdraw')
                        ->param('user', $user->id),
                    // ->param('user', $user->id),
                    Button::make('❌ No, cancel transaction')
                        ->action('withdraw')
                        ->param('reset', $pendingTransaction->id),
                    //  ->param('user', $user->id),
                ]))->dispatch();
        }

        // Do nothing
    }

    protected function canHandle(string $action): bool
    {
        if ($action === 'handle') {
            return false;
        }

        if (!method_exists($this, $action)) {
            if (array_key_exists($action, $this->commands)) {
                return true;
            }

            return false;
        }

        $reflector = new ReflectionMethod($this::class, $action);
        if (!$reflector->isPublic()) {
            return false;
        }

        return true;
    }

    protected function handleInlineQuery(InlineQuery $inlineQuery): void
    {
        parent::handleInlineQuery($inlineQuery); // TODO: Change the autogenerated stub
    }
}
